Вот небольшое описание курсовой работы.
Оно является частью readme, поэтому его надо красиво оформить.
В начале добавь описание того что происходит. По правилам readme гитхаба
# Concurrent-computing
Разработаем программу симулирующая конкурентную работу. Данная программа доступна на Java. Ищите курсовую.
В компьютерном программировании конкурентность — способность компьютера справляться с множеством разных задач одновременно. Давайте возьмем для примера использование браузера. Если мы гуляем по сети, происходит много вещей одновременно. Например, идет скачивание файла в то время как мы слушаем музыку и скролим веб сайт в другой в кладке. Можно сказать, что компьютер выполняет несколько задач одновременно. Если бы компьютеры так не умели, нам бы пришлось ждать окончание скачивания файла, чтобы продолжить слушать музыку или скролить сайт.
Архитектура ЦПУ устроена таким образом, что одно ядро может выполнять лишь одно действие в единицу времени. В наши дни на рынке все еще есть множество одноядерных процессоров. Но если у вас компьютер с одноядерным процессором, то неужели мы не сможем скачивать файл, слушать музыку и листать новостную ленту в другой вкладке одновременно? Конечно сможем, а достигается это с помощью конкурентности. Давайте посмотрим диаграмму, которая демонстрирует как одноядерный ЦПУ справляется с примером с браузером.
![image](https://github.com/DEPTH-STRIDA/Concurrent-computing/assets/92984389/08efeef9-7008-4ee6-8d79-048b788bdfc6)
Как мы можем увидеть, все задачи разбиваются на кусочки, которые делятся по приоритетности, а ЦПУ постоянно переключается между ними, создавая иллюзию одновременного исполнения.
Создадим программу на языке программирования Go, которая будет получать уже разбитые задачи и выполнять их. Программу реализуем с помощью событийно-ориентированной модели программирования. В центральном классе будет находится основной цикл, который выбирает и обрабатывает событие, при этом создаваться события будут в цикле.
Т.е. главный цикл обрабатывает список событий, в который динамически добавляются новые события.
У нас будет 3 типа событий: 1 – запрос новой задачи и предоставление доступа к процессору, 2 – выполнение задач, 3 – завершение работы программы при выполнении заранее запланированной задачи или при переполнении максимального возможного количества задач.
Рассмотрим события более детально.
1 тип: c самого начала у нас одно событие этого типа. При обработке происходит добавление задачи (увеличение L), добавление следующего события 1-го типа (с удалением обработанного), а если процессор свободен, то добавляется событие два (обработка только что добавленной задачи)
Время, которое идет вместе с кодом события указывает в какой момент времени оно случилось, т.е. выполняется моментально.
2 тип: данное событие символизирует конец обработки задачи и проверяет остались ли еще задачи. Если (L>0) есть еще необработанные задачи, то добавляется следующее событие 2. 
Время, которое идем вместе с кодом события указывает в какой момент времени закончилась работа задачи.
